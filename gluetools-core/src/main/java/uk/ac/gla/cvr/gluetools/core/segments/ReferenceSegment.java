package uk.ac.gla.cvr.gluetools.core.segments;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.function.BiFunction;

import org.w3c.dom.Element;

import uk.ac.gla.cvr.gluetools.core.document.ObjectReader;
import uk.ac.gla.cvr.gluetools.core.plugins.Plugin;
import uk.ac.gla.cvr.gluetools.core.plugins.PluginConfigContext;
import uk.ac.gla.cvr.gluetools.core.plugins.PluginUtils;

public class ReferenceSegment implements Plugin, IReferenceSegment, Cloneable {

	
	private int refStart, refEnd;

	public ReferenceSegment(int refStart, int refEnd) {
		super();
		this.refStart = refStart;
		this.refEnd = refEnd;
	}
	public ReferenceSegment(ObjectReader objectReader) {
		this(objectReader.intValue(REF_START),
				objectReader.intValue(REF_END));
	}
	
	public ReferenceSegment(PluginConfigContext pluginConfigContext,
			Element configElem) {
		configure(pluginConfigContext, configElem);
	}
	
	protected ReferenceSegment() {
	}
	
	@Override
	public void configure(PluginConfigContext pluginConfigContext,
			Element configElem) {
		setRefStart(PluginUtils.configureIntProperty(configElem, REF_START, true));
		setRefEnd(PluginUtils.configureIntProperty(configElem, REF_END, true));
	}
	
	@Override
	public Integer getRefStart() {
		return refStart;
	}
	public void setRefStart(Integer refStart) {
		this.refStart = refStart;
	}
	@Override
	public Integer getRefEnd() {
		return refEnd;
	}
	
	public void setRefEnd(Integer refEnd) {
		this.refEnd = refEnd;
	}
	

	public String toString() { return
		"Ref: ["+getRefStart()+", "+getRefEnd()+"]";
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + refEnd;
		result = prime * result + refStart;
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ReferenceSegment other = (ReferenceSegment) obj;
		if (refEnd != other.refEnd)
			return false;
		if (refStart != other.refStart)
			return false;
		return true;
	}

	
	public ReferenceSegment clone() {
		return new ReferenceSegment(refStart, refEnd);
	}
	
	/**
	 * Split a segment into two parts, a new left part of length <length>
	 * which is returned
	 * This supplied segment is then modified to be the remaining part.
	 */
	public static <A extends ReferenceSegment> Plugin truncateLeftSplit(A segment, int length) {
		@SuppressWarnings("unchecked")
		A newSegment = (A) segment.clone();
		int currentLength = segment.getCurrentLength();
		segment.truncateLeft(length);
		newSegment.truncateRight(currentLength-length);
		return newSegment;
	}
	
	/**
	 * Split a segment into two parts, a new right part of length <length>
	 * which is returned.
	 * The supplied segment is modified to be the remaining part.
	 */
	public static <A extends ReferenceSegment> Plugin truncateRightSplit(A segment, int length) {
		@SuppressWarnings("unchecked")
		A newSegment = (A) segment.clone();
		int currentLength = segment.getCurrentLength();
		segment.truncateRight(length);
		newSegment.truncateLeft(currentLength-length);
		return newSegment;
	}
	
	
	
	
	/** 
	 * given two lists of segments, and a function which generates a new segment
	 * equal to the overlapping region from two overlapping segments, 
	 * return a list of new segments which cover those locations which are covered by both lists.
	 * A segment in the returned list will have been generated by the segMerger function.
	 * The segMerger function must operate like this:
	 * 
	 * SA seg1;
	 * SB seg2;
	 * N merged = segMerger(seg1, seg2);
	 * where:
	 *   merged.getRefStart() == Math.max(seg1.getRefStart(), seg2.getRefStart())
	 *   merged.getRefEnd() == Math.min(seg1.getRefEnd(), seg2.getRefEnd())
	 */
	public static <N extends IReferenceSegment,
				   SA extends IReferenceSegment,
				   SB extends IReferenceSegment> List<N> 
	intersection(List<SA> segments1, List<SB> segments2, BiFunction<SA, SB, N> segMerger) {

		LinkedList<SA> segments1Linked = new LinkedList<SA>();
		for(SA seg1: segments1) {
			@SuppressWarnings("unchecked")
			SA seg1Copy = (SA) seg1.clone();
			segments1Linked.add(seg1Copy);
		}
		LinkedList<SB> segments2Linked = new LinkedList<SB>();
		for(SB seg2: segments2) {
			@SuppressWarnings("unchecked")
			SB seg2Copy = (SB) seg2.clone();
			segments2Linked.add(seg2Copy);
		}

		List<N> intersectionSegments = new ArrayList<N>();

		int nextSeg1Start = updateNextStart(segments1Linked);
		int nextSeg2Start = updateNextStart(segments2Linked);

		while(!segments1Linked.isEmpty() && !segments2Linked.isEmpty()) {

			boolean anyChange;
			// pass over segments in either list while they are not overlapping
			do {
				anyChange = false;
				// while segment1s are strictly to the left of remaining segment2s, 
				// skip them 
				while(!segments1Linked.isEmpty() &&
						segments1Linked.getFirst().getRefEnd() < nextSeg2Start) {
					segments1Linked.removeFirst();
					nextSeg1Start = updateNextStart(segments1Linked);
					anyChange = true;
				}
				// while segment2s are strictly to the left of remaining segment1s, 
				// skip them 
				while(!segments2Linked.isEmpty() &&
						segments2Linked.getFirst().getRefEnd() < nextSeg1Start) {
					segments2Linked.removeFirst();
					nextSeg2Start = updateNextStart(segments2Linked);
					anyChange = true;
				}
			} while(anyChange);

			if(!segments1Linked.isEmpty() && !segments2Linked.isEmpty()) {
				SA seg1 = segments1Linked.getFirst();
				SB seg2 = segments2Linked.getFirst();

				int seg1Start = nextSeg1Start;
				int seg1End = seg1.getRefEnd();
				int seg2Start = nextSeg2Start;
				int seg2End = seg2.getRefEnd();

				N mergedSegment = segMerger.apply(seg1, seg2);
				if(mergedSegment.getRefStart() != Math.max(seg1Start, seg2Start)) {
					throw new RuntimeException("Merged segment has incorrect refStart");
				}
				if(mergedSegment.getRefEnd() != Math.min(seg1End, seg2End)) {
					throw new RuntimeException("Merged segment has incorrect refEnd");
				}

				intersectionSegments.add(mergedSegment);

				/* [   seg1   ---
				 *    [  seg2   ---
				 */
				if(seg1Start <= seg2Start) {
					if(seg1End < seg2End) {
						/* [1   seg1   7]
						 *    [2 seg2     9]
						 */
						segments1Linked.removeFirst();
						seg2.truncateLeft(1 + (seg1End - seg2Start));
					} else if(seg1End == seg2End) {
						/* [1   seg1   7]
						 *    [2 seg2  7]
						 */
						segments1Linked.removeFirst();
						segments2Linked.removeFirst();
					} else {
						/* [1   seg1      9]
						 *    [2 seg2  7]
						 */
						seg1.truncateLeft(1 + (seg2End - seg1Start));
						segments2Linked.removeFirst();
					}
				} else {
					/*    [   seg1   ---
					 * [  seg2   ---
					 */
					if(seg1End < seg2End) {
						/*    [3   seg1   6]
						 * [1  seg2          9]
						 */
						segments1Linked.removeFirst();
						seg2.truncateLeft(1 + (seg1End - seg2Start));
					} else if(seg1End == seg2End) {
						/*    [3   seg1   6]
						 * [1  seg2       6]
						 */
						segments1Linked.removeFirst();
						segments2Linked.removeFirst();
					} else {
						/*    [3   seg1     9]
						 * [1  seg2       6]
						 */
						seg1.truncateLeft(1 + (seg2End - seg1Start));
						segments2Linked.removeFirst();
					}
				}
				nextSeg1Start = updateNextStart(segments1Linked);
				nextSeg2Start = updateNextStart(segments2Linked);
			}
		}


		return intersectionSegments;
	}
	
	private static int updateNextStart(LinkedList<? extends IReferenceSegment> segList) {
		if(segList.isEmpty()) {
			return Integer.MAX_VALUE;
		}
		return segList.getFirst().getRefStart();
	}


	
}
